# Story 2.4: Onboarding Middleware Redirect

## Status
Completed

## Story
**As a** new user,
**I want** to be automatically redirected to onboarding if I haven't completed it,
**so that** I don't skip the personalization flow.

## Acceptance Criteria
1. `middleware.ts` updated to check `user_profiles.onboarding_completed` field
2. Authenticated users with `onboarding_completed = false` redirect to `/onboarding`
3. Authenticated users with `onboarding_completed = true` access app normally
4. Unauthenticated users redirect to `/login` as usual (existing behavior)
5. Users on `/onboarding` path itself are not redirected (avoid infinite loop)
6. Middleware executes efficiently (<50ms overhead per request)

## Tasks / Subtasks

- [ ] Update `middleware.ts` (AC: 1, 2, 3, 4, 5)
  - [ ] Import Supabase client: `import { createServerClient } from '@supabase/ssr'`
  - [ ] Get session: `const { data: { session } } = await supabase.auth.getSession()`
  - [ ] Check if user authenticated
  - [ ] If authenticated AND not on `/onboarding` path:
    - [ ] Query `user_profiles` for `onboarding_completed`:
      ```typescript
      const { data: profile } = await supabase
        .from('user_profiles')
        .select('onboarding_completed')
        .eq('user_id', session.user.id)
        .single();
      ```
    - [ ] If `!profile?.onboarding_completed`:
      - [ ] Redirect to `/onboarding`
  - [ ] If not authenticated AND accessing protected route:
    - [ ] Redirect to `/login` (existing behavior)

- [ ] Add path exclusion logic (AC: 5)
  - [ ] Check current path: `request.nextUrl.pathname`
  - [ ] Exclude onboarding routes from redirect:
    ```typescript
    if (request.nextUrl.pathname.startsWith('/onboarding')) {
      return NextResponse.next(); // Don't redirect on onboarding pages
    }
    ```
  - [ ] Also exclude public routes: `/login`, `/signup`, `/api/auth/*`

- [ ] Optimize middleware performance (AC: 6)
  - [ ] Use `select('onboarding_completed')` to fetch only needed field
  - [ ] Cache session check result (Supabase client handles this)
  - [ ] Avoid database query for unauthenticated users
  - [ ] Use `.single()` to fetch one row only

- [ ] Update middleware matcher config
  - [ ] Ensure matcher excludes static assets:
    ```typescript
    export const config = {
      matcher: ['/((?!_next/static|_next/image|favicon.ico).*)']
    };
    ```

- [ ] Test middleware (AC: 1-6)
  - [ ] Test new user (no profile):
    - [ ] Login → Auto-redirect to `/onboarding`
    - [ ] Complete onboarding → Access `/dashboard` without redirect
  - [ ] Test existing user (onboarding complete):
    - [ ] Login → Access `/dashboard` directly
  - [ ] Test unauthenticated user:
    - [ ] Access `/dashboard` → Redirect to `/login` (existing)
  - [ ] Test performance:
    - [ ] Measure middleware execution time with `console.time()`
    - [ ] Verify <50ms overhead

## Dev Notes

### Middleware Logic Flow
```
Request → Middleware
  ↓
Is user authenticated?
  No → Accessing protected route? → Yes → Redirect /login
  Yes ↓
Is path /onboarding*?
  Yes → Allow (return next())
  No ↓
Query user_profiles.onboarding_completed
  ↓
onboarding_completed === false?
  Yes → Redirect /onboarding
  No → Allow (return next())
```

### Middleware Implementation Pattern
From `docs/architecture-v2-course-system.md` lines 1317-1349:

```typescript
// middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextRequest, NextResponse } from 'next/server';

export async function middleware(request: NextRequest) {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    // ... cookie config
  );

  const { data: { session } } = await supabase.auth.getSession();

  // Redirect unauthenticated users
  if (!session && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Check onboarding completion for authenticated users
  if (session && !request.nextUrl.pathname.startsWith('/onboarding')) {
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('onboarding_completed')
      .eq('user_id', session.user.id)
      .single();

    if (!profile?.onboarding_completed) {
      return NextResponse.redirect(new URL('/onboarding', request.url));
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)']
};
```

### Protected Routes
Routes requiring authentication:
- `/dashboard`
- `/courses`
- `/lessons`
- `/profile`
- Existing: `/reader`, `/tutor`, `/flashcards`, `/library`, `/vocabulary`

### Public Routes (No Redirect)
- `/login`
- `/signup`
- `/onboarding` (allow incomplete onboarding users)
- `/api/auth/*` (Supabase auth callbacks)
- Landing page `/` (optional: redirect authenticated users to dashboard)

### Performance Optimization
- **Single Query:** Fetch only `onboarding_completed` field, not entire profile
- **Early Exit:** Check path before querying database
- **Session Caching:** Supabase client caches session internally
- **Avoid N+1:** Use `.single()` to fetch one row, not array

### Edge Cases
1. **User deletes profile manually:** Middleware should create default profile (handled by API)
2. **Concurrent requests:** Supabase RLS prevents race conditions
3. **Slow database:** Timeout middleware after 200ms, allow request through (fail-open)

### Source Tree
```
middleware.ts           # Updated with onboarding check
app/
  onboarding/           # Excluded from redirect
  dashboard/            # Protected, requires onboarding complete
  login/                # Public
  signup/               # Public
```

### Testing

**Test File Location:** `middleware.test.ts`

**Unit Tests:**
```typescript
import { middleware } from './middleware';
import { createServerClient } from '@supabase/ssr';

vi.mock('@supabase/ssr');

describe('Onboarding Middleware', () => {
  it('redirects authenticated user without completed onboarding', async () => {
    const mockSupabase = {
      auth: { getSession: vi.fn().mockResolvedValue({
        data: { session: { user: { id: 'user123' } } }
      })},
      from: vi.fn(() => ({
        select: vi.fn(() => ({
          eq: vi.fn(() => ({
            single: vi.fn().mockResolvedValue({
              data: { onboarding_completed: false }
            })
          }))
        }))
      }))
    };

    vi.mocked(createServerClient).mockReturnValue(mockSupabase as any);

    const request = new NextRequest('http://localhost/dashboard');
    const response = await middleware(request);

    expect(response?.status).toBe(307); // Redirect
    expect(response?.headers.get('location')).toContain('/onboarding');
  });

  it('allows authenticated user with completed onboarding', async () => {
    const mockSupabase = {
      auth: { getSession: vi.fn().mockResolvedValue({
        data: { session: { user: { id: 'user123' } } }
      })},
      from: vi.fn(() => ({
        select: vi.fn(() => ({
          eq: vi.fn(() => ({
            single: vi.fn().mockResolvedValue({
              data: { onboarding_completed: true }
            })
          }))
        }))
      }))
    };

    vi.mocked(createServerClient).mockReturnValue(mockSupabase as any);

    const request = new NextRequest('http://localhost/dashboard');
    const response = await middleware(request);

    expect(response).toBeUndefined(); // No redirect (NextResponse.next())
  });

  it('does not redirect on /onboarding path', async () => {
    const mockSupabase = {
      auth: { getSession: vi.fn().mockResolvedValue({
        data: { session: { user: { id: 'user123' } } }
      })}
    };

    vi.mocked(createServerClient).mockReturnValue(mockSupabase as any);

    const request = new NextRequest('http://localhost/onboarding');
    const response = await middleware(request);

    expect(response).toBeUndefined(); // Allowed
  });
});
```

**Integration Tests:**
1. Create test user with `onboarding_completed = false`
2. Authenticate as test user
3. Navigate to `/dashboard`
4. Verify redirect to `/onboarding`
5. Complete onboarding
6. Navigate to `/dashboard`
7. Verify no redirect (access granted)

**E2E Tests:** `tests/e2e/onboarding-flow.spec.ts`
```typescript
test('redirects incomplete user to onboarding', async ({ page }) => {
  await page.goto('/login');
  await page.fill('[name="email"]', 'newuser@example.com');
  await page.fill('[name="password"]', 'password');
  await page.click('button[type="submit"]');

  // Should auto-redirect to onboarding
  await expect(page).toHaveURL('/onboarding');
});

test('allows completed user to access dashboard', async ({ page }) => {
  await page.goto('/login');
  await page.fill('[name="email"]', 'existing@example.com');
  await page.fill('[name="password"]', 'password');
  await page.click('button[type="submit"]');

  // Should access dashboard without redirect
  await expect(page).toHaveURL('/dashboard');
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-02 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
